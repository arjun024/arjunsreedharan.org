package main

import(
	"os"
	"fmt"
	"net/http"
	"io/ioutil"
	"encoding/json"
)

const debug = false
const SPACE_URL_ENCODED = "%20"
const REFERER = "http://arjunsreedharan.org"
const GOOGLE_URI = "https://ajax.googleapis.com" +
			"/ajax/services/search/web?v=1.0&q="

type api_data struct {
	GsearchResultClass string
	unescapedUrl string
	url string
	visibleUrl string
	cacheUrl string
	title string
	titleNoFormatting string
	content string
}

func stringify(argv []string) string {
	query := ""
	i := 1
	size := len(argv) 
	for i < size {
		query += os.Args[i]
		i++
		if i < size {
			query += SPACE_URL_ENCODED
		}
	}
	return query
}

/* fills the struct with first result */
func parse_json(str []byte, j *api_data) {
	err := json.Unmarshal(str, j)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Unable to parse json: %s\n",
			err.Error())
		os.Exit(1)
	}
}

func main() {
	var query string
	var json api_data
	query = GOOGLE_URI + stringify(os.Args)
	if query == GOOGLE_URI {
		fmt.Println("SYNTAX: whats <SOMETHING>")
		os.Exit(0)
	}

	client := &http.Client{}
	req, err := http.NewRequest("GET", query, nil)
	req.Header.Set("Referer", REFERER)

	resp, err := client.Do(req)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error in making HTTP request: %s\n",
			err.Error())
		os.Exit(1)
	}

	defer resp.Body.Close()

	contents, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error in reading HTTP response: %s\n",
			err.Error())
		os.Exit(1)
	}

	parse_json(contents, &json)

	fmt.Printf("%v\n", json)
}
